# Vercel에서 "실제 브라우저" 모드가 안 되는 이유

## 요약

**Vercel은 서버리스(함수 단위 실행) 플랫폼**이라, Puppeteer로 실제 브라우저를 띄우고 플레이어를 로드하는 방식은 **구조적으로 맞지 않습니다.**  
그래서 Vercel에 올리면 항상 **"요청 전송만"** 모드로만 동작하고, 시청자 수는 증가하지 않습니다.

---

## 1. Vercel이 하는 일

- **서버리스 함수**: 요청이 올 때마다 함수를 한 번 실행하고, 응답을 보낸 뒤 **프로세스가 곧 종료**됩니다.
- **상태 없음**: 다음 요청은 다른 인스턴스에서 처리될 수 있고, **계속 켜져 있는 서버**가 없습니다.
- **실행 시간·메모리 제한**: 함수당 실행 시간(예: 10초~60초), 메모리(예: 1GB) 등 제한이 있습니다.

---

## 2. "실제 브라우저" 모드가 필요한 것

- **Puppeteer + Chromium**: 실제 브라우저 실행 파일과 수백 MB 메모리.
- **긴 실행 시간**: 페이지 로드 + 플레이어 로드 + (YouTube 기준) 30초 이상 재생 유지.
- **동시에 여러 브라우저**: 인스턴스 5~300개만큼 **동시에** 브라우저를 띄우고 유지.

→ **계속 떠 있는 프로세스**와 **충분한 메모리·시간**이 필요합니다.

---

## 3. 왜 Vercel에서는 불가능한가

| Vercel 특성 | "실제 브라우저" 모드 요구 |
|-------------|---------------------------|
| 요청 끝나면 프로세스 종료 | 브라우저를 몇십 초~몇 분 유지해야 함 |
| 함수 실행 시간 제한 (초 단위) | 페이지 로드 + 재생 유지로 30초 이상 필요 |
| 배포 패키지 크기 제한 | Chromium 포함 시 수백 MB |
| 동시에 여러 "함수"를 한 작업에 묶기 어려움 | 인스턴스 N개 = 브라우저 N개 동시 실행 |

그래서 **Vercel 함수 안에서 Puppeteer로 실제 브라우저를 여러 개 띄워 시청자 수를 반영하는 구조**는 현실적으로 맞지 않습니다.

---

## 4. "실제 작동"을 원할 때 선택지

- **로컬**: `npm run server` → Node 서버가 계속 떠 있고, Puppeteer로 실제 브라우저 실행 → **시청자 수 반영 가능**.
- **클라우드에서 실제 작동**을 원하면:
  - **Railway**, **Render**, **Fly.io**, **AWS EC2**, **DigitalOcean** 등 **항상 떠 있는 서버**가 있는 플랫폼에 `server.js`(Node + Express + Socket.io + Puppeteer)를 배포해야 합니다.
  - 이때는 "서버리스"가 아니라 **일반 Node 서버**로 배포하는 방식입니다.

정리하면, **Vercel = 요청 전송만(시청자 수 미반영)**, **실제 반영 = 로컬 또는 위 같은 서버 호스팅**입니다.
